"""
Save the results generated by the model. These results are movie frames, mat files or images of each layer

:copyright: Copyright 2013-2023, see AUTHORS.
:license: GPLv3, see LICENSE for details.
"""

import sys
import numpy as np
import scipy
from PIL import Image

from VIS_VisualVR import Highlight


def resize(im, shape):
    '''
    simple image scaling
    https://stackoverflow.com/questions/48121916/numpy-resize-rescale-image

    params: im    -- numpy array of image
            shape -- new shape for array
    '''

    nR0 = len(im)     # source number of rows
    nC0 = len(im[0])  # source number of columns

    return np.array([[im[int(nR0 * r / shape[0])][int(nC0 * c / shape[1])]
                      for c in range(shape[1])] for r in range(shape[0])])

def Prepare_Frames(Step, ModelParam, params, rHVA23, rFEFm, VisualField, TargetNo, Scene_Objects):
    '''
    Prepare graphical output of the simulation in png files.
    Each file illustrates the searched Targets, Visual Field, rate of neurons in HVA Layer 2/3 and FEFm.

    params: Step               -- step of the simulation
            ModelParam, params -- dictionary of all required parameters for model simulation
            rHVA23             -- current firing rates of HVA Layer 2/3
            rFEFm              -- current firing rates of FEF Movement Layer
            VisualField        -- numpy array with current Visual Field
            TargetNo           -- index of searched target object
            Scene_Objects      -- list of all valid objects in this simulation
    '''

    ### Make filename
    ResultFileName = ModelParam['ResultDir'] + ModelParam['OutputFileName']
    ResultFileName += "Step_{:>04d}.png".format(Step)

    # We need this Movie Frame counter to make a movie in MakeMovie() function
    if ModelParam['Make_Movie']:
        ModelParam['Movie_Frame'] += 1

    # Spatial layout: (height, width)
    Result_Image = np.asarray(Image.open(ModelParam['DataDir'] + ModelParam['BG_Filename'])) / 255.
    RDF = np.asarray(Image.open(ModelParam['DataDir'] + 'forMovie/Flash_Red_Up.png')) / 255.

    HVA23_Enlarge_Factor = 2

    TI_NRow              = 50
    TI_NCol              = 50
    TI_Top_Margin        = 250
    TI_Left_Margin       = 950

    VF_Scale_Factor      = 0.65
    VF_NRow              = int(ModelParam['resIm'][1] * VF_Scale_Factor)
    VF_NCol              = int(ModelParam['resIm'][0] * VF_Scale_Factor)
    VF_Top_Margin        = 500
    VF_Left_Margin       = 950

    FEFm_Top_Margin      = 20
    FEFm_Left_Margin     = 600

    MI_Top_Margin        = 80
    MI_Left_Margin       = 150

    HVA23_Top_Margin     = 600
    HVA23_Left_Margin    = 180

    ## Placing the objects in output canvas
    Target_Matrix = np.ones([TI_NRow * 1 + (1 + 1) * 2,
                             TI_NCol * len(Scene_Objects) + (len(Scene_Objects) + 1) * 2, 3])
    for i, obj in enumerate(Scene_Objects):
        if obj == TargetNo:
            Result_Image[TI_Top_Margin + TI_NRow:RDF.shape[0] + TI_Top_Margin + TI_NRow,
                         TI_Left_Margin+i*TI_NCol+(i+1)*2:RDF.shape[1]+TI_Left_Margin+i*TI_NCol+(i+1)*2] = RDF
        Target_Filename = ModelParam['DataDir'] + "forMovie/Target{:>02d}.png".format(obj)
        Target_Image = np.asarray(Image.open(Target_Filename)) / 255.
        TI = resize(Target_Image, [TI_NRow, TI_NCol, 3])
        Row_Offset = 2
        Col_Offset = i * TI_NCol + i * 2 + 2
        Target_Matrix[Row_Offset:Row_Offset + TI_NRow, Col_Offset:Col_Offset + TI_NCol, :] = TI
    Result_Image[TI_Top_Margin:Target_Matrix.shape[0] + TI_Top_Margin,
                 TI_Left_Margin:Target_Matrix.shape[1] + TI_Left_Margin] = Target_Matrix

    ## Placing the visual field in output canvas
    VF = resize(VisualField, [VF_NRow, VF_NCol, 3])
    Result_Image[VF_Top_Margin:VF.shape[0]+VF_Top_Margin,
                 VF_Left_Margin:VF.shape[1]+VF_Left_Margin] = VF

    ## Placing the FEFm in output canvas
    # reshape rates of FEFm into RGB image with size of VF
    FEFm_Img = (resize(rFEFm, [VF_NCol, VF_NRow])*np.ones((3, 1, 1))).T
    Result_Image[FEFm_Top_Margin:FEFm_Img.shape[0] + FEFm_Top_Margin,
                 FEFm_Left_Margin:FEFm_Img.shape[1] + FEFm_Left_Margin] = FEFm_Img

    ## Placing the Mental Image in output canvas
    Mental_Img = np.zeros([VF_NRow, VF_NCol, 3])
    if FEFm_Img.max() > 0:
        Mental_Img = (0.25 + 0.75 * FEFm_Img) * VF
    Result_Image[MI_Top_Margin:Mental_Img.shape[0]+MI_Top_Margin,
                 MI_Left_Margin:Mental_Img.shape[1]+MI_Left_Margin] = Mental_Img

    ## Placing the HVA23 in output canvas
    # number of Planes arranged in (height, width)
    NView = (5, 3)
    # space between Planes
    space = 1
    # init sub image for rates of HVA23 incl. small wihite space between Planes
    HVA23_Img = np.ones([params['V4L23_shape'][1] * NView[0] + (NView[0]-1)*space,
                         params['V4L23_shape'][0] * NView[1] + (NView[1]-1)*space])
    for row in range(NView[0]):
        for col in range(NView[1]):
            Plane = row*NView[1] + col
            if Plane <= params['V4L23_shape'][2]:
                Row_Offset = row * (params['V4L23_shape'][1]+space)
                Col_Offset = col * (params['V4L23_shape'][0]+space)
                HVA23_Img[Row_Offset:Row_Offset+params['V4L23_shape'][1],
                          Col_Offset:Col_Offset+params['V4L23_shape'][0]] = rHVA23.T[Plane]
    tmp = resize(HVA23_Img, [int(round(HVA23_Img.shape[0] * HVA23_Enlarge_Factor)),
                             int(round(HVA23_Img.shape[1] * HVA23_Enlarge_Factor))])
    tmp = (tmp.T*np.ones((3, 1, 1))).T
    Result_Image[HVA23_Top_Margin:tmp.shape[0] + HVA23_Top_Margin,
                 HVA23_Left_Margin:tmp.shape[1] + HVA23_Left_Margin] = tmp

    Image.fromarray((Result_Image*255).astype('uint8')).save(ResultFileName)

    if Step != 0:
        sys.stdout.write("\033[F")      # Back to previous line
        sys.stdout.write("\033[F")      # Back to previous line
        sys.stdout.write("\033[K")      # Clear line

    print(Highlight("\nThe frame related to step %d has been saved." % Step, 'Blue', Bold=True))


def SaveHVA23(Step, ModelParam, params, rHVA23, rPFC, HVA23_Enlarge_Factor=5):
    '''
    Since the number of planes (features) in HVA layers might be too much for appearance in the
    result png file completely, this function is designed to illustrate only planes of HVA Layer 2/3
    corresponding to the searched object (Target) in separated png files.

    params: Step                 -- current step of the simulation
            ModelParam           -- dictionary of all required parameters for model simulation
            rHVA23               -- current firing rates of HVA Layer 2/3
            rPFC                 -- current firing rates of PFC Layer
            HVA23_Enlarge_Factor -- integer to enlarge plot
    '''

    HVA23_Filename = ModelParam['ResultDir'] + "HVA23_" + ModelParam['OutputFileName'].split('_')[-2]
    HVA23_Filename += "_Step{:>04d}.png".format(Step)

    RR = 3
    CC = 5
    PxMargin = 1
    Counter = -1
    HVA23_Img = np.ones([params['V4L23_shape'][1] * RR + (RR + 1) * PxMargin,
                         params['V4L23_shape'][0] * CC + (CC + 1) * PxMargin])
    for Plane in range(params['V4L23_shape'][2]):
        if rPFC[Plane] != 0:
            Counter += 1
            if Counter == (RR * CC):
                Counter -= 1
            Row_Offset = (Counter // CC) * params['V4L23_shape'][1] + (Counter // CC) * PxMargin + PxMargin
            Col_Offset = (Counter % CC) * params['V4L23_shape'][0] + (Counter % CC) * PxMargin + PxMargin
            HVA23_Img[Row_Offset:Row_Offset+params['V4L23_shape'][1],
                      Col_Offset:Col_Offset+params['V4L23_shape'][0]] = rHVA23.T[Plane]
    tmp = resize(HVA23_Img, [int(round(HVA23_Img.shape[0] * HVA23_Enlarge_Factor)),
                             int(round(HVA23_Img.shape[1] * HVA23_Enlarge_Factor))])
    Image.fromarray((tmp*255).astype('uint8')).save(HVA23_Filename)

def SaveHVA4(Step, ModelParam, params, rHVA4, rPFC, HVA4_Enlarge_Factor=2):
    '''
    Since the number of planes (features) in HVA layers might be too much for appearance in the
    result png file completely, this function is designed to illustrate only planes of HVA Layer 4
    corresponding to the searched object (Target) in separated png files.

    params: Step                -- current step of the simulation
            ModelParam          -- dictionary of all required parameters for model simulation
            rHVA4               -- current firing rates of HVA Layer 4
            rPFC                -- current firing rates of PFC Layer
            HVA4_Enlarge_Factor -- integer to enlarge plot
    '''

    HVA4_Filename = ModelParam['ResultDir'] + "HVA4_" + ModelParam['OutputFileName'].split('_')[-2]
    HVA4_Filename += "_Step{:>04d}.png".format(Step)

    RR = 3
    CC = 5
    PxMargin = 1
    Counter = -1
    HVA4_Img = np.ones([params['V4L4_shape'][1] * RR + (RR + 1) * PxMargin,
                        params['V4L4_shape'][0] * CC + (CC + 1) * PxMargin])
    for Plane in range(params['V4L4_shape'][2]):
        if rPFC[Plane] != 0:
            Counter += 1
            if Counter == (RR * CC):
                Counter -= 1
            Row_Offset = (Counter // CC) * params['V4L4_shape'][1] + (Counter // CC) * PxMargin + PxMargin
            Col_Offset = (Counter % CC) * params['V4L4_shape'][0] + (Counter % CC) * PxMargin + PxMargin
            HVA4_Img[Row_Offset:Row_Offset+params['V4L4_shape'][1],
                     Col_Offset:Col_Offset+params['V4L4_shape'][0]] = rHVA4.T[Plane]
    tmp = resize(HVA4_Img, [int(round(HVA4_Img.shape[0] * HVA4_Enlarge_Factor)),
                            int(round(HVA4_Img.shape[1] * HVA4_Enlarge_Factor))])
    Image.fromarray((tmp*255).astype('uint8')).save(HVA4_Filename)


def SaveResults(Step, ModelParam, rV1C, rPFC, rHVA23, rHVA4, rFEFv, rFEFvm, rFEFm):
    '''
    save the rates of the network populations as well as the pre-processed visual field in mat files

    params: Step       -- current step of the simulation
            ModelParam -- dictionary of all required parameters for model simulation
            rV1C       -- numpy array with pre-processed visual field
            PFC_Pop    -- current firing rates of PFC Layer
            rHVA23     -- current firing rates of HVA Layer 2/3
            rHVA4      -- current firing rates of HVA Layer 4
            rFEFv      -- current firing rates of FEF Visual Layer
            rFEFvm     -- current firing rates of FEF Visio-Movement Layer
            rFEFm      -- current firing rates of FEF Movement Layer
    '''

    if not (ModelParam['SaveValuesrV1C'] or ModelParam['SaveValuesPFC'] or \
            ModelParam['SaveValuesHVA23'] or ModelParam['SaveValuesHVA4'] or \
            ModelParam['SaveValuesFEFv'] or ModelParam['SaveValuesFEFvm'] or ModelParam['SaveValuesFEFm']):
        return

    ResultFileName = ModelParam['ResultDir'] + ModelParam['OutputFileName']
    ResultFileName += "Step_{:>04d}.mat".format(Step)

    Tmp = {}
    if ModelParam['SaveValuesrV1C']:
        Tmp['rV1C'] = rV1C
    if ModelParam['SaveValuesPFC']:
        Tmp['rPFC'] = rPFC
    if ModelParam['SaveValuesHVA23']:
        Tmp['rHVA23'] = rHVA23
    if ModelParam['SaveValuesHVA4']:
        Tmp['rHVA4'] = rHVA4
    if ModelParam['SaveValuesFEFv']:
        Tmp['rFEFv'] = rFEFv
    if ModelParam['SaveValuesFEFvm']:
        Tmp['rFEFvm'] = rFEFvm
    if ModelParam['SaveValuesFEFm']:
        Tmp['rFEFm'] = rFEFm

    scipy.io.savemat(ResultFileName, Tmp)


def SavePP(ModelParam, params, rV1C):
    '''
    Save Pre-Processed Image.

    params: ModelParam, params -- dictionary of all required parameters for model simulation
            rV1C               -- numpy array with rates of V1-Complex neurons (pre-processed image)
    '''

    if ModelParam['SaveImageV1C']:
        ModelParam['SaveImageV1C'] = False
        ResultFileName = ModelParam['ResultDir'] + 'PPImage_'+ ModelParam['imresize_Kernel'] + '_'
        ResultFileName += ModelParam['OutputFileName'].split('_')[-2] + '.png'
        NRow =params['V1_shape'][2]
        NCol = params['V1_shape'][3]
        AddRow = (NRow + 1) * 2
        AddCol = (NCol + 1) * 2
        V1C_Img = np.ones([params['V1_shape'][1] * NRow + AddRow,
                           params['V1_shape'][0] * NCol + AddCol]) / 2.0
        for Plane in range(params['V1_shape'][3]):
            Row_Offset = (Plane // NCol) * params['V1_shape'][1] + (Plane // NCol) * 2 + 2
            Col_Offset = (Plane % NCol) * params['V1_shape'][0] + (Plane % NCol) * 2 + 2
            for Channel in range(params['V1_shape'][2]):
                Row_Offset = Channel * params['V1_shape'][1] + 2 * (Channel + 1)
                Col_Offset = Plane   * params['V1_shape'][0] + 2 * (Plane   + 1)
                for i in range(params['V1_shape'][1]):
                    for j in range(params['V1_shape'][0]):
                        V1C_Img[Row_Offset + i, Col_Offset + j] = rV1C[i, j, Channel, Plane]
        tmp = resize(V1C_Img, [V1C_Img.shape[0] * 3, V1C_Img.shape[1] * 3])
        Image.fromarray((tmp*255).astype('uint8')).save(ResultFileName)
        print("Pre-processed image has been saved successfully.")


def SaveVF(VF_Counter, VF, ModelParam):
    '''
    Save Visual Field.

    params: VF_Counter -- counter determining number of saving VF used for filename
            VF         -- numpy array with Visual Field
            ModelParam -- dictionary of all required parameters for model simulation

    return: VF_Counter -- incremented counter
    '''

    VF_Counter += 1
    VF_Filename = ModelParam['ResultDir'] + 'VisualField{:>03d}.png'.format(VF_Counter)
    Image.fromarray((VF*255).astype('uint8')).save(VF_Filename)

    return VF_Counter